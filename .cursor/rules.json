{
  "rules": [
    {
      "name": "hand-evaluator",
      "description": "Hand evaluation",
      "glob": "src/evaluator/*.ts",
      "content": "# Hand Evaluation\n\nThe hand evaluation system is designed to be flexible, supporting different poker variants while maintaining high performance.\n\n## Core Components\n\n1. **HandEvaluator (Abstract Base Class)**\n   - Provides common evaluation logic\n   - Defines the interface for variant-specific evaluators\n\n2. **Variant-Specific Evaluators**\n   - TexasHoldemEvaluator: For Texas Hold'em (best 5 of 7 cards)\n   - OmahaEvaluator: For Omaha (must use exactly 2 hole cards and 3 board cards)\n\n3. **HandRanking System**\n   - Uses a numerical ranking system for quick comparisons\n   - Supports both high and low hand evaluations\n\n## Hand Ranking Algorithm\n\nThe ranking algorithm combines:\n\n1. Hand category (straight flush, four of a kind, etc.) as the primary factor\n2. Card ranks within the category for tie-breaking\n\nFor example, the rank value for a hand might be structured as:\n\n```\nRank = (HandCategory * 10^10) + (PrimaryRank * 10^8) + (SecondaryRank * 10^6) + ...\n```\n\nThis allows for simple numerical comparison between hands.\n\n## Performance Optimizations\n\n1. **Card Bit Representation**\n   - Cards are internally represented as integers with bit flags\n   - Allows for fast set operations (finding pairs, flushes, etc.)\n\n2. **Early Returns**\n   - Evaluation short-circuits when clear winners/losers are determined\n\n3. **Score Caching**\n   - Repeated evaluations of the same hand yield cached results\n\n## Usage Example\n\n```typescript\n// Create an evaluator for Texas Hold'em\nconst evaluator = new TexasHoldemEvaluator();\n\n// Evaluate a hand\nconst holeCards = [new Card(Suit.SPADES, Rank.ACE), new Card(Suit.SPADES, Rank.KING)];\nconst communityCards = [\n  new Card(Suit.SPADES, Rank.QUEEN),\n  new Card(Suit.SPADES, Rank.JACK),\n  new Card(Suit.SPADES, Rank.TEN),\n  new Card(Suit.HEARTS, Rank.TWO),\n  new Card(Suit.DIAMONDS, Rank.THREE)\n];\n\nconst handRanking = evaluator.evaluate(holeCards, communityCards);\n// Returns a ranking for a Royal Flush\n```\n\n## Adding New Variants\n\nTo add a new poker variant, create a new class extending `HandEvaluator` and implement the required methods:\n\n```typescript\nclass NewVariantEvaluator extends HandEvaluator {\n  evaluate(holeCards: Card[], communityCards: Card[]): number {\n    // Implementation specific to the new variant\n  }\n  \n  getHandDescription(holeCards: Card[], communityCards: Card[]): string {\n    // Return a human-readable description of the best hand\n  }\n}\n```"
    },
    {
      "name": "models-implementation",
      "description": "Read this to get an overview of the data models in the system",
      "glob": "src/models/*.ts",
      "content": "# Data Models Implementation\n\nThe poker engine uses a set of core data models to represent game entities. These models form the foundation of the system and are used throughout the codebase.\n\n## Core Models\n\n### Card\n\nRepresents a playing card with:\n- Suit (Hearts, Diamonds, Clubs, Spades)\n- Rank (2-10, J, Q, K, A)\n- Methods for comparing, display, and conversion\n\n```typescript\nconst card = new Card(Suit.HEARTS, Rank.ACE);\nconsole.log(card.toString()); // \"Aâ™¥\"\n```\n\n### Deck\n\nRepresents a standard 52-card deck with:\n- Card creation and management\n- Shuffling algorithms\n- Drawing/dealing methods\n\n```typescript\nconst deck = new Deck();\ndeck.shuffle();\nconst card = deck.drawCard();\n```\n\n### Hand\n\nRepresents a player's hand:\n- Collection of cards\n- Methods for hand evaluation\n- Support for different poker variants\n\n```typescript\nconst hand = new Hand([new Card(Suit.SPADES, Rank.ACE), new Card(Suit.SPADES, Rank.KING)]);\n```\n\n### Player\n\nRepresents a player in the game:\n- Player identification and status\n- Chip stack management\n- Betting actions and capabilities\n- Cards and hand evaluation\n\n```typescript\nconst player = new Player(\"p1\", \"Player 1\", 1000);\nplayer.addToStack(500);\nplayer.placeBet(100);\n```\n\n### Action\n\nRepresents player actions:\n- Action types (Fold, Check, Call, Bet, Raise)\n- Action validation\n- Amount handling for bets/raises\n\n```typescript\nconst action = new Action(ActionType.BET, 100);\nplayer.performAction(action);\n```\n\n### Pot\n\nManages the money in play:\n- Main pot and side pots handling\n- Contribution tracking per player\n- Pot resolution for winners\n\n```typescript\nconst pot = new Pot();\npot.addContribution(player1.id, 100);\n// Later in showdown\npot.awardToWinners([player1, player2]);\n```\n\n### Table\n\nRepresents the poker table:\n- Player positions and management\n- Community cards\n- Game stage/state tracking\n- Dealer button and blinds management\n\n```typescript\nconst table = new Table(9, 10, 20); // 9-player table with 10/20 blinds\ntable.addPlayer(player1, 0); // Add player at seat 0\n```\n\n## Model Relationships\n\n- **Table** contains **Players** and community cards\n- **Players** have a **Hand** of **Cards** and place bets in the **Pot**\n- **Players** perform **Actions** during their turn\n- The **Deck** provides **Cards** to **Players** and the table\n\n## Design Principles\n\n1. **Immutability**: Most models are designed to be immutable or have controlled mutation paths\n2. **Encapsulation**: Models handle their own state and validation\n3. **Separation of Concerns**: Models focus on data representation, not game logic\n4. **Type Safety**: TypeScript types ensure correct usage throughout the system\n\n## Usage in Game Logic\n\nThese models are used by the game engine to:\n- Track game state\n- Process player actions\n- Evaluate winning hands\n- Manage betting rounds\n- Handle pot distribution\n\nThe models themselves are generally logic-agnostic, allowing the engine to apply game rules to them."
    },
    {
      "name": "project-structure",
      "description": "Read this file before and after each request, add a checkmark next to a part after it has been implemented and finished, and create a new rule that describes its implementation and goals",
      "glob": "**/*.ts",
      "content": "# Project Structure\n\nRead this file before and after each request, add a checkmark next to a part after it has been implemented and finished, and create a new rule that describes its implementation and goals\n\n# Project Structure\n\nThe project follows a modular architecture that separates core game logic from presentation and network components:\n\n- [x] `src/models/` - Data structures representing game entities\n- `src/engine/` - Core game logic and state machine\n  - [x] State Machine - Manages game states and transitions\n  - [x] Game Engine - Coordinates game flow and processes actions\n- [x] `src/rules/` - Game variant rules\n- [x] `src/evaluator/` - Hand evaluation logic\n- `src/utils/` - Helper functions\n- [x] `src/types/` - TypeScript types/interfaces\n- `src/server/` - Server-side networking components\n  - [x] WebSocket Service - Handles real-time communication\n  - [x] Room Manager - Manages game rooms and players\n- `src/events/` - Event system for communication\n  - [x] Event Emitter - Base publisher/subscriber implementation\n  - [x] Game Events - Game-specific event definitions\n  - [x] Game Event Bus - Central hub for game events\n\n# Core Components\n\nThe engine is built around these key components:\n\n1. [x] Game Engine - Coordinates game flow and processes actions\n2. [x] State Machine - Manages game states (Setup, Dealing, Betting, Showdown)\n3. [x] Player Manager - Tracks player states, stacks, and positions\n4. [x] Dealer - Manages deck and deals cards\n5. [x] Pot Manager - Handles pot calculations (implemented in models/Pot.ts)\n6. [x] Hand Evaluator - Evaluates and ranks poker hands\n7. [x] Rule Provider - Configures different game variants\n\n# Models Implementation\n\nThe following models have been implemented:\n\n1. [x] Card - Representation of a playing card with suit and rank\n2. [x] Deck - Standard deck of 52 cards with shuffling and dealing functionality\n3. [x] Hand - Collection of cards with evaluation placeholders\n4. [x] Player - Player representation with stack, cards, and betting functionality\n5. [x] Action - Player actions (fold, check, call, bet, raise)\n6. [x] Pot - Pot management with support for side pots\n7. [x] Table - Game table with players, community cards, and game state\n\n# Hand Evaluator Implementation\n\nThe hand evaluator supports different poker variants and is configurable:\n\n1. [x] Base Hand Evaluator - Abstract class with common evaluation logic\n2. [x] Texas Hold'em Evaluator - Best 5 cards from 7 (2 hole + 5 community)\n3. [x] Omaha Evaluator - Must use exactly 2 hole cards and 3 community cards\n4. [x] Hi-Lo Support - Can evaluate both high and low hands\n5. [x] Game Variant Config - Configurable rules for different poker variants\n\n# State Machine Implementation\n\nThe state machine manages the game flow through different states:\n\n1. [x] Generic State Machine - Reusable implementation for any state transitions\n2. [x] Game State Machine - Poker-specific state management\n3. [x] State Transition Rules - Defines valid transitions between game states\n4. [x] State Change Notifications - Event system for state changes\n\n# Game Engine Implementation\n\nThe game engine coordinates all components and manages the game flow:\n\n1. [x] Game Flow Control - Manages progression through game states\n2. [x] Player Action Processing - Handles player actions and validates them\n3. [x] Card Dealing - Deals hole cards and community cards\n4. [x] Hand Resolution - Determines winners and awards pots\n5. [x] Event System - Notifies components of game events\n\n# Client-Server Architecture\n\nThe system is designed for networked play with:\n\n1. [x] Event System - Publisher/Subscriber pattern for state changes\n2. [x] Room Manager - Handles multiple game tables\n3. [x] Socket Service - Real-time communication\n4. [ ] Authentication Service - Player identity and sessions\n5. [x] State Synchronization - Maintains consistent game state through events\n\n# Next Steps\n\nAfter completing the core engine, these are the priorities for implementation:\n\n1. [x] Player Manager - Centralized management of players across tables\n2. [x] Event System - Communication between components\n3. [x] Server Components - Room management and WebSocket service\n4. [ ] Authentication Service - Player identity and sessions\n5. [ ] Client Interface - Frontend implementation\n6. [ ] Game UI - User interface for playing poker"
    },
    {
      "name": "event-system",
      "description": "Read this to understand the Event System architecture that powers component communication",
      "glob": "src/events/*.ts",
      "content": "# Event System Architecture\n\nThe event system is a core component of the poker engine, enabling communication between different system components in a decoupled way. It provides a reliable mechanism for notifying interested parties about game state changes and player actions.\n\n## Core Components\n\nThe event system consists of three primary components:\n\n1. **EventEmitter**: The foundation of the event system, implementing a publisher/subscriber pattern\n2. **GameEventTypes and GameEventData**: Definitions for all game events and their data types\n3. **GameEventBus**: A singleton that provides type-safe access to game events\n\n## Event Emitter\n\nThe `EventEmitter` is a generic implementation of the publisher/subscriber pattern. It provides methods to:\n\n- Subscribe to events (`on`, `once`)\n- Unsubscribe from events (`off`)\n- Emit events to all subscribers (`emit`)\n\nIt's designed to be type-safe, allowing components to subscribe to events with the correct data type for each event.\n\n```typescript\n// Simplified example\nemitter.on(\"game:started\", (data: GameStartedData) => {\n  console.log(`Game ${data.gameId} started with ${data.players.length} players`);\n});\n```\n\n## Game Events\n\nThe event system defines a comprehensive set of game events through the `GameEventType` enum, along with their corresponding data types in the `GameEventData` interface. Events are organized into logical categories:\n\n- **Game lifecycle events**: game creation, start, and end\n- **State machine events**: state transitions\n- **Player events**: joining, leaving, actions\n- **Dealer events**: card dealing\n- **Betting events**: blinds posting, betting rounds\n- **Showdown events**: hand reveals, winners\n- **Pot events**: pot creation, updates, and awards\n- **Timer events**: timer start/end\n- **Error events**: system errors\n\n## Game Event Bus\n\nThe `GameEventBus` is a singleton that extends the `EventEmitter` with type-safe methods specifically for game events. It ensures that:\n\n1. All event handlers receive properly typed data\n2. All events include required metadata (like timestamps)\n3. Events can be easily discovered and subscribed to\n\n```typescript\n// Example of using the GameEventBus\ngameEventBus.onGameEvent(GameEventType.PLAYER_ACTION, (data) => {\n  // TypeScript knows data has playerId, action, etc.\n  console.log(`Player ${data.playerId} performed ${data.action.type}`);\n});\n```\n\n## Integration with WebSocket Service\n\nThe event system integrates with the WebSocket service to:\n\n1. Forward relevant game events to clients\n2. Sanitize sensitive data before sending (e.g., hide other players' cards)\n3. Route client actions to the appropriate game events\n\n```typescript\n// Example of WebSocket integration\ngameEventBus.on(\"*\", ({ type, data }) => {\n  if (data && data.gameId) {\n    wsService.sendToRoom(data.gameId, {\n      type,\n      payload: sanitizeEventData(type, data)\n    });\n  }\n});\n```\n\n## Usage Patterns\n\n### Component Communication\n\nComponents communicate through events rather than direct method calls, allowing them to remain decoupled:\n\n```typescript\n// When a state changes\ngameStateMachine.addStateChangeListener((oldState, newState) => {\n  gameEventBus.emitGameEvent(GameEventType.STATE_CHANGED, {\n    previousState: oldState,\n    currentState: newState,\n    timestamp: Date.now()\n  });\n});\n```\n\n### Room Management\n\nThe RoomManager uses events to notify about room changes:\n\n```typescript\n// When a player joins a room\ngameEventBus.emitGameEvent(GameEventType.PLAYER_JOINED, {\n  playerId,\n  player,\n  seatIndex,\n  timestamp: Date.now()\n});\n```\n\n## Event Flow\n\n1. Game components emit events to the GameEventBus\n2. The GameEventBus notifies all subscribed listeners\n3. For network events, the WebSocketService forwards events to relevant clients\n4. Client actions are converted back into events on the server\n\n## Testing\n\nThe event system is thoroughly tested with:\n\n- Unit tests for the `EventEmitter`\n- Integration tests for the `GameEventBus`\n- Tests for event flow between components\n- Tests for WebSocket integration"
    }
  ]
} 