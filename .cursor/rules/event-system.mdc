---
description:
globs:
alwaysApply: false
---
# Event System Architecture

The event system is a core component of the poker engine, enabling communication between different system components in a decoupled way. It provides a reliable mechanism for notifying interested parties about game state changes and player actions.

## Core Components

The event system consists of three primary components:

1. **EventEmitter**: The foundation of the event system, implementing a publisher/subscriber pattern
2. **GameEventTypes and GameEventData**: Definitions for all game events and their data types
3. **GameEventBus**: A singleton that provides type-safe access to game events

## Event Emitter

The `EventEmitter` is a generic implementation of the publisher/subscriber pattern. It provides methods to:

- Subscribe to events (`on`, `once`)
- Unsubscribe from events (`off`)
- Emit events to all subscribers (`emit`)

It's designed to be type-safe, allowing components to subscribe to events with the correct data type for each event.

```typescript
// Simplified example
emitter.on("game:started", (data: GameStartedData) => {
  console.log(`Game ${data.gameId} started with ${data.players.length} players`);
});
```

## Game Events

The event system defines a comprehensive set of game events through the `GameEventType` enum, along with their corresponding data types in the `GameEventData` interface. Events are organized into logical categories:

- **Game lifecycle events**: game creation, start, and end
- **State machine events**: state transitions
- **Player events**: joining, leaving, actions
- **Dealer events**: card dealing
- **Betting events**: blinds posting, betting rounds
- **Showdown events**: hand reveals, winners
- **Pot events**: pot creation, updates, and awards
- **Timer events**: timer start/end
- **Error events**: system errors

## Game Event Bus

The `GameEventBus` is a singleton that extends the `EventEmitter` with type-safe methods specifically for game events. It ensures that:

1. All event handlers receive properly typed data
2. All events include required metadata (like timestamps)
3. Events can be easily discovered and subscribed to

```typescript
// Example of using the GameEventBus
gameEventBus.onGameEvent(GameEventType.PLAYER_ACTION, (data) => {
  // TypeScript knows data has playerId, action, etc.
  console.log(`Player ${data.playerId} performed ${data.action.type}`);
});
```

## Integration with WebSocket Service

The event system integrates with the WebSocket service to:

1. Forward relevant game events to clients
2. Sanitize sensitive data before sending (e.g., hide other players' cards)
3. Route client actions to the appropriate game events

```typescript
// Example of WebSocket integration
gameEventBus.on("*", ({ type, data }) => {
  if (data && data.gameId) {
    wsService.sendToRoom(data.gameId, {
      type,
      payload: sanitizeEventData(type, data)
    });
  }
});
```

## Usage Patterns

### Component Communication

Components communicate through events rather than direct method calls, allowing them to remain decoupled:

```typescript
// When a state changes
gameStateMachine.addStateChangeListener((oldState, newState) => {
  gameEventBus.emitGameEvent(GameEventType.STATE_CHANGED, {
    previousState: oldState,
    currentState: newState,
    timestamp: Date.now()
  });
});
```

### Room Management

The RoomManager uses events to notify about room changes:

```typescript
// When a player joins a room
gameEventBus.emitGameEvent(GameEventType.PLAYER_JOINED, {
  playerId,
  player,
  seatIndex,
  timestamp: Date.now()
});
```

## Event Flow

1. Game components emit events to the GameEventBus
2. The GameEventBus notifies all subscribed listeners
3. For network events, the WebSocketService forwards events to relevant clients
4. Client actions are converted back into events on the server

## Testing

The event system is thoroughly tested with:

- Unit tests for the `EventEmitter`
- Integration tests for the `GameEventBus`
- Tests for event flow between components
- Tests for WebSocket integration
